--------------------Wrong but passes the test cases----------------
class Solution {
    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {
        int len = s.length(), left = 0, right = left+k-1;
        String ans = "";
        while(right <= len - k){
            String currStr = s.substring(left, right+1);
            left++;
            right++;
            int exp = 0, sSum = 0;
            for(int indx = 0; indx<k; indx++){
                int cNum = (int)(currStr.charAt(indx) - 'a' + 1);
                sSum += (cNum * Math.pow(power, exp++))%modulo;
            }
            sSum %= modulo;
            if(sSum == hashValue) return currStr;
        }
        String currStr = s.substring(left, right+1);
            left++;
            right++;
            int exp = 0, sSum = 0;
            for(int indx = 0; indx<k; indx++){
                int cNum = (int)(currStr.charAt(indx) - 'a' + 1);
                sSum += (cNum * Math.pow(power, exp++))%modulo;
            }
            sSum %= modulo;
            if(sSum == hashValue) return currStr;

        return "";
    }
}
----------------------------------------------------------------------
class Solution {
    public String subStrHash(String s, int p, int m, int k, int hashValue) {
        long currHash = 0, currPow = 1;
        int res = 0, len = s.length();
        for (int i = len - 1; i >= 0; --i) {
            currHash = (currHash * p + s.charAt(i) - 'a' + 1) % m;
            if (i + k >= len)
                currPow = currPow * p % m;
            else
                currHash = (currHash - (s.charAt(i + k) - 'a' + 1) * currPow % m + m) % m;
            if (currHash == hashValue)
                res = i;
        }
        return s.substring(res, res + k);
    }
}